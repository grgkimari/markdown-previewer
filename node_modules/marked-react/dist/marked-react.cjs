'use strict';

var react = require('react');
var marked = require('marked');

const htmlUnescapes = {
    '&amp;': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&#39;': "'",
};
/** Used to match HTML entities and HTML characters. */
const reEscapedHtml = /&(?:amp|lt|gt|quot|#(?:0+)?39);/g;
const reHasEscapedHtml = RegExp(reEscapedHtml.source);
const unescape = (str = '') => {
    return reHasEscapedHtml.test(str) ? str.replace(reEscapedHtml, (entity) => htmlUnescapes[entity] || "'") : str;
};
const joinBase = (path, base) => {
    if (!base) {
        return path;
    }
    try {
        return new URL(path, base).href;
    }
    catch (_a) {
        return path;
    }
};

class ReactParser {
    constructor(options) {
        this.renderer = options.renderer;
    }
    parse(tokens) {
        return tokens.map((token) => {
            switch (token.type) {
                case 'space': {
                    return null;
                }
                case 'heading': {
                    const level = token.depth;
                    return this.renderer.heading(this.parseInline(token.tokens), level);
                }
                case 'paragraph': {
                    return this.renderer.paragraph(this.parseInline(token.tokens));
                }
                case 'text': {
                    const textTokens = token.tokens;
                    return textTokens ? this.parseInline(textTokens) : token.text;
                }
                case 'blockquote': {
                    const quote = this.parse(token.tokens);
                    return this.renderer.blockquote(quote);
                }
                case 'list': {
                    const children = token.items.map((item) => {
                        var _a;
                        const listItemChildren = [];
                        if (item.task) {
                            listItemChildren.push(this.renderer.checkbox((_a = item.checked) !== null && _a !== void 0 ? _a : false));
                        }
                        listItemChildren.push(this.parse(item.tokens));
                        return this.renderer.listItem(listItemChildren);
                    });
                    return this.renderer.list(children, token.ordered);
                }
                case 'code': {
                    return this.renderer.code(token.text, token.lang);
                }
                case 'html': {
                    return this.renderer.html(token.text);
                }
                case 'table': {
                    const headerCells = token.header.map((cell, index) => {
                        return this.renderer.tableCell(this.parseInline(cell.tokens), { header: true, align: token.align[index] });
                    });
                    const headerRow = this.renderer.tableRow(headerCells);
                    const header = this.renderer.tableHeader(headerRow);
                    const bodyChilren = token.rows.map((row) => {
                        const rowChildren = row.map((cell, index) => {
                            return this.renderer.tableCell(this.parseInline(cell.tokens), {
                                header: false,
                                align: token.align[index],
                            });
                        });
                        return this.renderer.tableRow(rowChildren);
                    });
                    const body = this.renderer.tableBody(bodyChilren);
                    return this.renderer.table([header, body]);
                }
                case 'hr': {
                    return this.renderer.hr();
                }
                default: {
                    console.warn(`Token with "${token.type}" type was not found`); // eslint-disable-line no-console
                    return null;
                }
            }
        });
    }
    parseInline(tokens) {
        return tokens.map((token) => {
            switch (token.type) {
                case 'text': {
                    return this.renderer.text(unescape(token.text));
                }
                case 'strong': {
                    return this.renderer.strong(this.parseInline(token.tokens));
                }
                case 'em': {
                    return this.renderer.em(this.parseInline(token.tokens));
                }
                case 'del': {
                    return this.renderer.del(this.parseInline(token.tokens));
                }
                case 'codespan': {
                    return this.renderer.codespan(unescape(token.text));
                }
                case 'link': {
                    return this.renderer.link(token.href, this.parseInline(token.tokens));
                }
                case 'image': {
                    return this.renderer.image(token.href, token.text, token.title);
                }
                case 'html': {
                    return this.renderer.html(token.text);
                }
                case 'br': {
                    return this.renderer.br();
                }
                case 'escape': {
                    return this.renderer.text(token.text);
                }
                default: {
                    console.warn(`Token with "${token.type}" type was not found`); // eslint-disable-line no-console
                    return null;
                }
            }
        });
    }
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}

var _ReactRenderer_instances, _ReactRenderer_elId, _ReactRenderer_options, _ReactRenderer_h, _ReactRenderer_incrementElId;
class ReactRenderer {
    constructor(options = {}) {
        _ReactRenderer_instances.add(this);
        _ReactRenderer_elId.set(this, 0);
        _ReactRenderer_options.set(this, void 0);
        const { renderer } = options;
        __classPrivateFieldSet(this, _ReactRenderer_options, options, "f");
        if (renderer && typeof renderer === 'object') {
            Object.entries(renderer).forEach(([key, value]) => {
                const rendererName = key;
                const rendererFunction = value;
                if (!this[rendererName] || rendererName === 'elementId' || typeof rendererFunction !== 'function') {
                    return;
                }
                this[rendererName];
                this[rendererName] = (...args) => {
                    __classPrivateFieldGet(this, _ReactRenderer_instances, "m", _ReactRenderer_incrementElId).call(this);
                    return rendererFunction.apply(this, args);
                };
            });
        }
    }
    get elementId() {
        return __classPrivateFieldGet(this, _ReactRenderer_elId, "f");
    }
    heading(children, level) {
        return __classPrivateFieldGet(this, _ReactRenderer_instances, "m", _ReactRenderer_h).call(this, `h${level}`, children);
    }
    paragraph(children) {
        return __classPrivateFieldGet(this, _ReactRenderer_instances, "m", _ReactRenderer_h).call(this, 'p', children);
    }
    link(href, text) {
        const url = joinBase(href, __classPrivateFieldGet(this, _ReactRenderer_options, "f").baseURL);
        const target = __classPrivateFieldGet(this, _ReactRenderer_options, "f").openLinksInNewTab ? '_blank' : null;
        return __classPrivateFieldGet(this, _ReactRenderer_instances, "m", _ReactRenderer_h).call(this, 'a', text, { href: url, target });
    }
    image(src, alt, title) {
        const url = joinBase(src, __classPrivateFieldGet(this, _ReactRenderer_options, "f").baseURL);
        return __classPrivateFieldGet(this, _ReactRenderer_instances, "m", _ReactRenderer_h).call(this, 'img', null, { src: url, alt, title });
    }
    codespan(code, lang = null) {
        const className = lang ? `${__classPrivateFieldGet(this, _ReactRenderer_options, "f").langPrefix}${lang}` : null;
        return __classPrivateFieldGet(this, _ReactRenderer_instances, "m", _ReactRenderer_h).call(this, 'code', code, { className });
    }
    code(code, lang) {
        return __classPrivateFieldGet(this, _ReactRenderer_instances, "m", _ReactRenderer_h).call(this, 'pre', this.codespan(code, lang));
    }
    blockquote(children) {
        return __classPrivateFieldGet(this, _ReactRenderer_instances, "m", _ReactRenderer_h).call(this, 'blockquote', children);
    }
    list(children, ordered) {
        return __classPrivateFieldGet(this, _ReactRenderer_instances, "m", _ReactRenderer_h).call(this, ordered ? 'ol' : 'ul', children);
    }
    listItem(children) {
        return __classPrivateFieldGet(this, _ReactRenderer_instances, "m", _ReactRenderer_h).call(this, 'li', children);
    }
    checkbox(checked) {
        return __classPrivateFieldGet(this, _ReactRenderer_instances, "m", _ReactRenderer_h).call(this, 'input', null, { type: 'checkbox', disabled: true, checked });
    }
    table(children) {
        return __classPrivateFieldGet(this, _ReactRenderer_instances, "m", _ReactRenderer_h).call(this, 'table', children);
    }
    tableHeader(children) {
        return __classPrivateFieldGet(this, _ReactRenderer_instances, "m", _ReactRenderer_h).call(this, 'thead', children);
    }
    tableBody(children) {
        return __classPrivateFieldGet(this, _ReactRenderer_instances, "m", _ReactRenderer_h).call(this, 'tbody', children);
    }
    tableRow(children) {
        return __classPrivateFieldGet(this, _ReactRenderer_instances, "m", _ReactRenderer_h).call(this, 'tr', children);
    }
    tableCell(children, flags) {
        const tag = flags.header ? 'th' : 'td';
        return __classPrivateFieldGet(this, _ReactRenderer_instances, "m", _ReactRenderer_h).call(this, tag, children, { align: flags.align });
    }
    strong(children) {
        return __classPrivateFieldGet(this, _ReactRenderer_instances, "m", _ReactRenderer_h).call(this, 'strong', children);
    }
    em(children) {
        return __classPrivateFieldGet(this, _ReactRenderer_instances, "m", _ReactRenderer_h).call(this, 'em', children);
    }
    del(children) {
        return __classPrivateFieldGet(this, _ReactRenderer_instances, "m", _ReactRenderer_h).call(this, 'del', children);
    }
    text(text) {
        return text;
    }
    html(html) {
        return html;
    }
    hr() {
        return __classPrivateFieldGet(this, _ReactRenderer_instances, "m", _ReactRenderer_h).call(this, 'hr');
    }
    br() {
        return __classPrivateFieldGet(this, _ReactRenderer_instances, "m", _ReactRenderer_h).call(this, 'br');
    }
}
_ReactRenderer_elId = new WeakMap(), _ReactRenderer_options = new WeakMap(), _ReactRenderer_instances = new WeakSet(), _ReactRenderer_h = function _ReactRenderer_h(el, children = null, props = {}) {
    const elProps = {
        key: `marked-react-${this.elementId}`,
    };
    __classPrivateFieldGet(this, _ReactRenderer_instances, "m", _ReactRenderer_incrementElId).call(this);
    return react.createElement(el, Object.assign(Object.assign({}, props), elProps), children);
}, _ReactRenderer_incrementElId = function _ReactRenderer_incrementElId() {
    __classPrivateFieldSet(this, _ReactRenderer_elId, __classPrivateFieldGet(this, _ReactRenderer_elId, "f") + 1, "f");
};

const validateComponentProps = (props) => {
    if (props.value && typeof props.value !== 'string') {
        throw new TypeError(`[marked-react]: Expected value to be of type string but got ${typeof props.value}`);
    }
    if (props.children && typeof props.children !== 'string') {
        throw new TypeError(`[marked-react]: Expected children to be of type string but got ${typeof props.children}`);
    }
};
const Markdown = (props) => {
    var _a, _b;
    validateComponentProps(props);
    // lexer options
    const lexerOptions = {
        breaks: props.breaks,
        gfm: props.gfm,
    };
    // convert input markdown into tokens
    const markdownString = (_b = (_a = props.value) !== null && _a !== void 0 ? _a : props.children) !== null && _b !== void 0 ? _b : '';
    const tokens = props.isInline
        ? marked.Lexer.lexInline(markdownString, lexerOptions)
        : marked.Lexer.lex(markdownString, lexerOptions);
    // parser options
    const parserOptions = {
        renderer: new ReactRenderer({
            renderer: props.renderer,
            baseURL: props.baseURL,
            openLinksInNewTab: props.openLinksInNewTab,
            langPrefix: props.langPrefix,
        }),
    };
    const parser = new ReactParser(parserOptions);
    const children = props.isInline ? parser.parseInline(tokens) : parser.parse(tokens);
    return react.createElement(react.Fragment, null, children);
};
Markdown.defaultProps = {
    isInline: false,
    breaks: false,
    gfm: true,
    baseURL: undefined,
    openLinksInNewTab: true,
    langPrefix: 'language-',
    renderer: undefined,
};

module.exports = Markdown;
//# sourceMappingURL=marked-react.cjs.map
